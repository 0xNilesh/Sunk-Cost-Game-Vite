// SPDX-License-Identifier: GPL-3.0
pragma soliditypp ^0.8.0;

contract WagmiPot {
    /* Events */
    event PotCreated(address _from, uint256 _potIndex);
    event RewardClaimed(address _from, uint256 _potIndex);
    event PotBought(address _from, uint256 _potIndex, uint256 potCurrentPrice, uint256 potEndTime);
    /* ------ */
  
    /* Variables */
    uint256 public potCreationFee;
    address public owner;

    uint256 public totalPotsCreated;

    struct Pot {
      address PotOwner;
      uint256 maxTimerLimit;
      uint256 buyInIncrementAmount;
      uint256 burnAmount;
      uint256 extensionAmount;
      address winner;
      uint256 potAmount;
      uint256 currentPrice;
      vitetoken tokenId;
      uint256 start;
      uint256 end;
      bool claimed;
    }

    mapping(uint256 => Pot) public Pots;
    /* -------- */

    constructor (uint256 creationFee) {
        potCreationFee = creationFee;
        owner = msg.sender;
        totalPotsCreated = 0;
    }

    function createPot(uint256 _initialTimer, uint256 _maxTimerLimit, uint256 _buyInIncrementAmount, uint256 _burnAmount, uint256 _extensionAmount) public payable returns (uint256) {
      require(msg.value >= potCreationFee, "Amount sent is less than the fee required");
      require(_initialTimer >= _maxTimerLimit, "Initial timer must be more than equal to max timer limit");

      uint256 PotId = totalPotsCreated++;
      Pot storage pot = Pots[PotId];
      pot.maxTimerLimit = _maxTimerLimit;
      pot.buyInIncrementAmount = _buyInIncrementAmount;
      pot.burnAmount = _burnAmount;
      pot.extensionAmount = _extensionAmount;
      pot.currentPrice = _buyInIncrementAmount;
      pot.PotOwner = msg.sender;
      pot.winner = msg.sender;
      pot.potAmount = 0;
      pot.tokenId = msg.token;
      pot.start = block.timestamp;
      pot.end = _initialTimer + pot.start;
      pot.claimed = false;

      emit PotCreated(msg.sender, PotId);
      return PotId;
    }

    function viewTime() view public returns (uint256) {
      return block.timestamp;
    }

    function buyPot(uint256 _potIndex) public payable {
      require(Pots[_potIndex].end >= block.timestamp, "Pot Expired");
      require(msg.token == Pots[_potIndex].tokenId, "You can't buy this pot with this token");
      require(msg.value >= Pots[_potIndex].currentPrice, "Pot price is more than amount sent");

      if(Pots[_potIndex].end - block.timestamp < Pots[_potIndex].maxTimerLimit) 
        Pots[_potIndex].end += Pots[_potIndex].extensionAmount;
      Pots[_potIndex].currentPrice += Pots[_potIndex].buyInIncrementAmount;
      /* burn */
      Pots[_potIndex].potAmount += msg.value;
      Pots[_potIndex].winner = msg.sender;

      emit PotBought(msg.sender, _potIndex, Pots[_potIndex].currentPrice, Pots[_potIndex].end);
    }

    function claimReward(uint256 _potIndex) public {
      require(Pots[_potIndex].claimed != true, "Reward is already claimed");
      require(Pots[_potIndex].end >= block.timestamp, "Pot is not expired yet");
      require(msg.sender == Pots[_potIndex].winner, "Unfortunately, you are not the winner of this Pot");

      uint256 amountToSend = Pots[_potIndex].potAmount;
      Pots[_potIndex].potAmount = 0;
      payable(msg.sender).transfer(Pots[_potIndex].tokenId, amountToSend);
      Pots[_potIndex].claimed = true;

      emit RewardClaimed(msg.sender, _potIndex);
    }
}